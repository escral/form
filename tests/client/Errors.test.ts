import { describe, it, expect, beforeEach } from 'vitest'
import Errors, { type UnparsedErrorsObject } from '~/lib/Errors'

/**
 * Generated by ChatGPT
 */
describe('Errors Class', () => {
    let errors: Errors

    beforeEach(() => {
        errors = new Errors()
    })

    it('should initialize with empty errors', () => {
        expect(errors.all()).toEqual({})
    })

    it('should record errors correctly', () => {
        const inputErrors: UnparsedErrorsObject = {
            field1: ['Error 1'],
            field2: ['Error 2'],
        }

        errors.record(inputErrors)

        expect(errors.all()).toEqual(inputErrors)
    })

    it('should determine if an error exists for a field', () => {
        const inputErrors: UnparsedErrorsObject = {
            field1: ['Error 1'],
            'nested.field2': ['Error 2'],
        }

        errors.record(inputErrors)

        expect(errors.has('field1')).toBe(true)
        expect(errors.has('field2')).toBe(false)
        expect(errors.has('nested')).toBe(true)
    })

    it('should get the first error for a field', () => {
        const inputErrors: UnparsedErrorsObject = {
            field1: ['Error 1', 'Error 2'],
            field2: ['Error 3'],
        }

        errors.record(inputErrors)

        expect(errors.first('field1')).toBe('Error 1')
        expect(errors.first('field2')).toBe('Error 3')
        expect(errors.first('nonexistent')).toBeUndefined()
    })

    it('should return the first error of any field if no key is specified', () => {
        const inputErrors: UnparsedErrorsObject = {
            field1: ['Error 1'],
            field2: ['Error 2'],
        }

        errors.record(inputErrors)

        expect(errors.first()).toBe('Error 1')
    })

    it('should get errors for a specific field', () => {
        const inputErrors: UnparsedErrorsObject = {
            field1: ['Error 1'],
        }

        errors.record(inputErrors)

        expect(errors.get('field1')).toEqual(['Error 1'])
        expect(errors.get('field2')).toEqual([])
    })

    it('should check if any errors exist', () => {
        expect(errors.any()).toBe(false)

        errors.record({ field1: ['Error 1']})

        expect(errors.any()).toBe(true)
    })

    it('should check if any specific keys have errors', () => {
        const inputErrors: UnparsedErrorsObject = {
            field1: ['Error 1'],
            field2: ['Error 2'],
        }

        errors.record(inputErrors)

        expect(errors.any(['field1', 'field3'])).toEqual(true)
    })

    it('should add new errors without removing existing ones', () => {
        errors.record({ field1: ['Error 1']})
        errors.add({ field2: ['Error 2']})

        expect(errors.all()).toEqual({
            field1: ['Error 1'],
            field2: ['Error 2'],
        })
    })

    it('should not duplicate errors when adding', () => {
        errors.record({ field1: ['Error 1']})
        errors.add({ field1: ['Error 1', 'Error 2']})

        expect(errors.get('field1')).toEqual(['Error 1', 'Error 2'])
    })

    it('should clear all errors', () => {
        errors.record({ field1: ['Error 1'], field2: ['Error 2']})

        errors.clear()

        expect(errors.all()).toEqual({})
    })

    it('should clear errors for a specific field', () => {
        errors.record({ field1: ['Error 1'], field2: ['Error 2']})

        errors.clear('field1')

        expect(errors.all()).toEqual({ field2: ['Error 2']})
    })

    it('should slice errors for a namespace', () => {
        const inputErrors: UnparsedErrorsObject = {
            'user.name': ['Required'],
            'user.email': ['Invalid'],
            other: ['Error'],
        }

        errors.record(inputErrors)

        const sliced = errors.slice('user')
        expect(sliced.all()).toEqual({ name: ['Required'], email: ['Invalid']})
    })
})
