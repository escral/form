import {
    afterAll,
    beforeEach,
    describe,
    expect,
    it,
} from 'vitest'
import { validateDataUsingCallbacks } from '~/validation/validateDataUsingCallbacks'
import ValidationError from '~/error/ValidationError'
import type { ValidationRulesSet } from '~/types/validation'

/**
 * Generated by ChatGPT
 */
describe('validateDataUsingCallbacks', () => {
    it('validates flat rules set', () => {
        const validationRules: ValidationRulesSet = {
            name: [
                (value: any) => (!value ? 'Name is required' : undefined),
                (value: any) => (value.length < 3 ? 'Name must be at least 3 characters' : undefined),
            ],
            email: [
                (value: any) => (!value ? 'Email is required' : undefined),
                (value: any) => (!/.+@.+\..+/.test(value) ? 'Invalid email format' : undefined),
            ],
        }

        try {
            validateDataUsingCallbacks({ name: '' }, validationRules)
            expect.fail('Should have thrown ValidationError')
        } catch (error: unknown) {
            expect(error).toBeInstanceOf(ValidationError)
            expect((error as ValidationError).errors.get('name')).toContain('Name is required')
        }

        try {
            validateDataUsingCallbacks({ email: 'invalid-email' }, validationRules)
            expect.fail('Should have thrown ValidationError')
        } catch (error: unknown) {
            expect(error).toBeInstanceOf(ValidationError)
            expect((error as ValidationError).errors.get('email')).toContain('Invalid email format')
        }

        try {
            validateDataUsingCallbacks({ name: 'Jo', email: 'invalid-email' }, validationRules)
            expect.fail('Should have thrown ValidationError')
        } catch (error: unknown) {
            expect(error).toBeInstanceOf(ValidationError)
            expect((error as ValidationError).errors.get('name')).toContain('Name must be at least 3 characters')
            expect((error as ValidationError).errors.get('email')).toContain('Invalid email format')
        }
    })

    it('validates nested rules set', () => {
        const validationRules: ValidationRulesSet = {
            user: {
                name: [
                    (value: any) => (!value ? 'Name is required' : undefined),
                    (value: any) => (value.length < 3 ? 'Name must be at least 3 characters' : undefined),
                ],
            },
        }

        try {
            validateDataUsingCallbacks({ user: { name: '' } }, validationRules)
            expect.fail('Should have thrown ValidationError')
        } catch (error: unknown) {
            expect(error).toBeInstanceOf(ValidationError)
            expect((error as ValidationError).errors.get('user.name')).toContain('Name is required')
            expect((error as ValidationError).errors.get('user.name')).toContain('Name must be at least 3 characters')
        }
    })

    it('validates arrays with nested rules', () => {
        const validationRules: ValidationRulesSet = {
            users: (value: any[]) => {
                const result: any = {}

                const rule = (ruleValue: any) => {
                    if (!ruleValue) {
                        return 'Name is required'
                    }
                }

                for (const index in value) {
                    result[index] = {
                        name: [rule],
                    }
                }

                return result
            },
        }

        try {
            validateDataUsingCallbacks({ users: [{ name: '' }, { name: 'Alice' }]}, validationRules)
            expect.fail('Should have thrown ValidationError')
        } catch (error: unknown) {
            expect(error).toBeInstanceOf(ValidationError)
            expect((error as ValidationError).errors.get('users.0.name')).toContain('Name is required')
            expect((error as ValidationError).errors.has('users.1.name')).toBe(false)
        }
    })
})
